use chrono::Utc;
use crate::analyzers::{AnalysisResult, FindingStatus};
use crate::scoring::ScoreCalculator;

pub struct MarkdownGenerator;

impl MarkdownGenerator {
    pub fn generate(
        owner: &str,
        repo: &str,
        overall_score: f64,
        results: &[(String, f64, AnalysisResult)],
    ) -> String {
        let timestamp = Utc::now().format("%Y-%m-%d %H:%M:%S UTC");
        let grade = ScoreCalculator::grade(overall_score);
        let badge_url = crate::output::generate_badge_url(overall_score);

        let mut report = format!(
            r#"# Repository Health Report

**Repository**: {}/{}
**Generated**: {}
**Overall Score**: {:.1}/100 ({})

![Repo Health Badge]({})

## Summary

This report provides an automated analysis of the repository's health across multiple dimensions.

"#,
            owner, repo, timestamp, overall_score, grade, badge_url
        );

        // Scores by category table
        report.push_str("## Scores by Category\n\n");
        report.push_str("| Category | Score | Grade | Weight | Details |\n");
        report.push_str("|----------|-------|-------|--------|----------|\n");

        for (name, weight, result) in results {
            let grade = ScoreCalculator::grade_short(result.score);
            report.push_str(&format!(
                "| {} | {:.1}/100 | {} | {:.0}% | {} |\n",
                name,
                result.score,
                grade,
                weight * 100.0,
                Self::truncate(&result.details, 50)
            ));
        }

        report.push_str("\n---\n\n");

        // Detailed analysis
        report.push_str("## Detailed Analysis\n\n");

        for (name, _, result) in results {
            report.push_str(&format!("### {}\n", name));
            report.push_str(&format!("**Score**: {:.1}/100\n\n", result.score));
            report.push_str(&format!("{}\n\n", result.details));

            if !result.findings.is_empty() {
                report.push_str("**Findings**:\n");
                for finding in &result.findings {
                    let icon = match finding.status {
                        FindingStatus::Positive => "✅",
                        FindingStatus::Warning => "⚠️",
                        FindingStatus::Missing => "❌",
                    };
                    report.push_str(&format!("- {} {}\n", icon, finding.message));
                }
                report.push_str("\n");
            }
        }

        report.push_str("---\n\n");

        // Recommendations
        report.push_str("## Recommendations\n\n");
        report.push_str(&Self::generate_recommendations(results));

        report.push_str("\n---\n\n");
        report.push_str("*Generated by repo-health*\n");

        report
    }

    fn generate_recommendations(results: &[(String, f64, AnalysisResult)]) -> String {
        let mut recommendations = Vec::new();

        for (name, _, result) in results {
            if result.score < 60.0 {
                recommendations.push(format!(
                    "- **{}**: Score is low ({:.1}/100). {}",
                    name,
                    result.score,
                    Self::get_recommendation_text(name)
                ));
            } else if result.score < 80.0 {
                recommendations.push(format!(
                    "- **{}**: Room for improvement ({:.1}/100). {}",
                    name,
                    result.score,
                    Self::get_recommendation_text(name)
                ));
            }
        }

        if recommendations.is_empty() {
            "This repository is in excellent health! Keep up the good work.".to_string()
        } else {
            recommendations.join("\n")
        }
    }

    fn get_recommendation_text(category: &str) -> &'static str {
        match category {
            "Documentation" => "Consider adding a comprehensive README, documentation folder, and contributing guidelines.",
            "Tests" => "Add test files and set up automated testing in your CI pipeline.",
            "CI/CD" => "Set up GitHub Actions or another CI/CD system to automate builds and tests.",
            "Dependencies" => "Add a dependency management file (Cargo.toml, package.json, etc.) and keep dependencies updated.",
            "Bus Factor" => "Encourage more contributors to participate in the project to distribute knowledge.",
            _ => "Review the findings above for specific improvements.",
        }
    }

    fn truncate(s: &str, max_len: usize) -> String {
        if s.len() <= max_len {
            s.to_string()
        } else {
            format!("{}...", &s[..max_len - 3])
        }
    }
}
